# -*- coding: utf-8 -*-

#    Model-View-Controller (MVC)
#
#    This file is part of The Crime Tracer.
#
#    Copyright (C) 2011 Free Software Gaming Geeks <fsgamedev@googlegroups.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


## @package mvc
#  features related with the MVC pattern
#
# This module contains classes for supporting the MVC
# pattern

try:
    import pygame
    from pygame.locals import *
    from base import Base
    from weakref import WeakKeyDictionary
except ImportError as err:
    try:
        import os
        path = os.path.basename(__file__)
        print((': '.join((path, str(err)))))
    # importing os failed, print a custom message...
    except ImportError:
        print((': '.join(("couldn't load module", str(err)))))
    exit(2)


## class of a generic event
#
# This is a superclass for any events that might be 
# generated by an object and sent to the EventManager
class Event(Base):
    ## create a new event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'Generic Event'

    ## the string representation of the event
    #
    # @param self the object pointer
    # @return the event's name as a plain string
    def __str__(self):
        return self.name

## class of tick-related events
#
# A tick event is an event that is generated periodically.
# Tick events are not used for tracking time (using a clock).
class TickEvent(Event):
    ## create a new tick event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'CPU Tick Event'

## class of quit-related events
#
# A quit event is generated whenever we must exit the game.
class QuitEvent(Event):
    ## create a new quit event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'Program Quit Event'

## class of escape-related events
#
# An escape event can be used for skipping a whole section, for
# example an introductory section of the game.
class EscapeEvent(Event):
    ## create a new escape event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'Escape Event'

## class of return-related events
#
# A return event can be used for skipping a single item, for
# example a slide of a slideshow.
class ReturnEvent(Event):
    ## create a new return event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'Return Event'

## class of safe exit related events
#
# A safe exit event is generated whenever we must execute safe_exit
class SafeExitEvent(Event):
    ## create a new quit event
    #
    # @param self the object pointer
    def __init__(self):
        self.name = 'Safe Exit Event'


## class of an event manager
#
# This class is responsible for coordinating the communication 
# between the Model, the View, and the Controller.
class EventManager(Base):
    ## create a new event manager
    #
    # @param self the object pointer
    def __init__(self):
        self.listeners = WeakKeyDictionary()
        self.eventQueue = []

    ## add a new listener
    #
    # @param self the object pointer
    # @param listener the name of the listener
    def register_listener(self, listener):
        self.listeners[listener] = True

    ## remove a listener
    #
    # @param self the object pointer
    # @param listener the name of the listener
    def unregister_listener(self, listener):
        if listener in self.listeners.keys():
            del self.listeners[listener]

    ## notify the related listener about the generated event
    #
    # @param self the object pointer
    # @param event the event to notify
    def post(self, event):
        # uncomment to help debugging
        if not isinstance(event, TickEvent):
            print(event)

        # if the weakref has died, it will be automatically
        # removed, so we do not need to worry about it
        for listener in self.listeners.keys():
            listener.notify(event)

## class of a keyboard controller
#
# This class is responsible for checking if "interested"
# keyboard keys have been pressed and generate the related
# events
class KeyboardController(Base):
    ## create a new keyboard controller and register it as a listener
    #
    # @param self the object pointer
    # @param manager the event manager
    def __init__(self, manager):
        self.event_manager = manager
        self.event_manager.register_listener(self)

    ## handle the related events 
    #
    # @param self the object pointer
    # @param event the generated event
    def notify(self, event):
        if isinstance(event, TickEvent):
            for event in pygame.event.get():
                ev = None
                if event.type == QUIT:
                    ev = QuitEvent()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_q:
                        ev = QuitEvent()
                    elif event.key == pygame.K_ESCAPE:
                        ev = EscapeEvent()
                    elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                        ev = ReturnEvent()
                if ev:
                    self.event_manager.post(ev)
                
## class of a busy waiting implementation
#
# This class is responsible for keeping the game executed until
# a quit event is generated
class BusyWaitingController:
    ## create a new busy waiting controller and register it as a listener
    #
    # @param self the object pointer
    # @param manager the event manager
    def __init__(self, manager):
        self.event_manager = manager
        self.event_manager.register_listener(self)
        self.keep_going = True

    ## continuously generate a tick event while executing
    #
    # @param self the object pointer
    def run(self):
        while self.keep_going:
            event = TickEvent()
            self.event_manager.post(event)

    ## handle the related events 
    #
    # @param self the object pointer
    # @param event the generated event
    def notify(self, event):
        if isinstance(event, QuitEvent):
            self.keep_going = False

# a testing class that creates a GUI View
class MainGUIView(Base):
    ## create a new main GUI view and register it as a listener
    #
    # @param self the object pointer
    # @param manager the event manager
    def __init__(self, manager):
        self.event_manager = manager
        self.event_manager.register_listener(self)
        pygame.init()
        self.window = pygame.display.set_mode((428, 428))
        pygame.display.set_caption('Example Game')
        self.background = pygame.Surface(self.window.get_size())
        self.background.fill((0, 0, 0))

    ## handle the related events 
    #
    # @param self the object pointer
    # @param event the generated event
    def notify(self, event):
        if isinstance(event, QuitEvent):
            print('ev', event)

# test the MVC pattern
def main():
    em = EventManager()
    kc = KeyboardController(em) # variable required even if not further used!
    gv = MainGUIView(em)

    # keeping running the game running until a quit event occurs
    sl = BusyWaitingController(em)
    sl.run()

if __name__ == '__main__':
    main()
